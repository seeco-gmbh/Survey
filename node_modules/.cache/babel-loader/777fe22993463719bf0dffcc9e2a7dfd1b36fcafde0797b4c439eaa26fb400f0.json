{"ast":null,"code":"import { t } from '../localization';\nexport const validators = {\n  required: value => {\n    if (value === undefined || value === null) return false;\n    if (typeof value === 'string') return value.trim() !== '';\n    if (Array.isArray(value)) return value.length > 0;\n    return true;\n  },\n  email: value => {\n    if (!value) return true;\n    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    return emailRegex.test(value);\n  },\n  minLength: (value, minLength) => {\n    if (!value) return true;\n    return String(value).length >= minLength;\n  },\n  maxLength: (value, maxLength) => {\n    if (!value) return true;\n    return String(value).length <= maxLength;\n  },\n  pattern: (value, pattern) => {\n    if (!value) return true;\n    const regex = new RegExp(pattern);\n    return regex.test(value);\n  },\n  min: (value, min) => {\n    if (!value && value !== 0) return true;\n    const num = Number(value);\n    return !isNaN(num) && num >= min;\n  },\n  max: (value, max) => {\n    if (!value) return true;\n    return Number(value) <= max;\n  },\n  minDate: (value, minDate) => {\n    if (!value) return true;\n    return new Date(value) >= new Date(minDate);\n  },\n  maxDate: (value, maxDate) => {\n    if (!value) return true;\n    return new Date(value) <= new Date(maxDate);\n  },\n  numeric: value => {\n    if (!value) return true;\n    return !isNaN(Number(value));\n  }\n};\n\n/**\n * Get localized error message for validation errors\n * @param {string} validationType - Type of validation that failed\n * @param {string} language - Current language code\n * @param {any} params - Additional parameters for the error message\n * @returns {string} - Localized error message\n */\nexport const getErrorMessage = (validationType, language, params) => {\n  switch (validationType) {\n    case 'required':\n      return t('validationRequired', language);\n    case 'email':\n      return t('validationEmail', language) || 'Please enter a valid email address';\n    case 'minLength':\n      return t('validationMinLength', language, {\n        length: params\n      }).replace('{length}', params);\n    case 'maxLength':\n      return t('validationMaxLength', language, {\n        length: params\n      }).replace('{length}', params);\n    case 'pattern':\n      return t('validationPattern', language);\n    case 'min':\n      return t('validationMin', language, {\n        min: params\n      }).replace('{min}', params);\n    case 'max':\n      return t('validationMax', language, {\n        max: params\n      }).replace('{max}', params);\n    case 'minDate':\n      return t('validationMinDate', language, {\n        minDate: params\n      }).replace('{minDate}', params);\n    case 'maxDate':\n      return t('validationMaxDate', language, {\n        maxDate: params\n      }).replace('{maxDate}', params);\n    default:\n      return t('validationGeneric', language) || 'Invalid input';\n  }\n};\n\n/**\n * Validate a field value against validation rules\n * @param {any} value - The value to validate\n * @param {Object} validationRules - Object containing validation rules\n * @returns {Object} - { isValid: boolean, errorType: string, param: any }\n */\nexport const validateField = (value, validationRules = {}) => {\n  if (!validationRules) return {\n    isValid: true\n  };\n  for (const [rule, param] of Object.entries(validationRules)) {\n    if (rule === 'required' && param && !validators.required(value)) {\n      return {\n        isValid: false,\n        errorType: 'required'\n      };\n    }\n    if (rule === 'email' && param && !validators.email(value)) {\n      return {\n        isValid: false,\n        errorType: 'email'\n      };\n    }\n    if (rule === 'minLength' && !validators.minLength(value, param)) {\n      return {\n        isValid: false,\n        errorType: 'minLength',\n        param\n      };\n    }\n    if (rule === 'maxLength' && !validators.maxLength(value, param)) {\n      return {\n        isValid: false,\n        errorType: 'maxLength',\n        param\n      };\n    }\n    if (rule === 'pattern' && !validators.pattern(value, param)) {\n      return {\n        isValid: false,\n        errorType: 'pattern'\n      };\n    }\n    if (rule === 'min' && !validators.min(value, param)) {\n      return {\n        isValid: false,\n        errorType: 'min',\n        param\n      };\n    }\n    if (rule === 'max' && !validators.max(value, param)) {\n      return {\n        isValid: false,\n        errorType: 'max',\n        param\n      };\n    }\n    if (rule === 'numeric' && !validators.numeric(value, param)) {\n      return {\n        isValid: false,\n        errorType: 'numeric',\n        param\n      };\n    }\n    if (rule === 'minDate' && !validators.minDate(value, param)) {\n      return {\n        isValid: false,\n        errorType: 'minDate',\n        param\n      };\n    }\n    if (rule === 'maxDate' && !validators.maxDate(value, param)) {\n      return {\n        isValid: false,\n        errorType: 'maxDate',\n        param\n      };\n    }\n  }\n  return {\n    isValid: true\n  };\n};","map":{"version":3,"names":["t","validators","required","value","undefined","trim","Array","isArray","length","email","emailRegex","test","minLength","String","maxLength","pattern","regex","RegExp","min","num","Number","isNaN","max","minDate","Date","maxDate","numeric","getErrorMessage","validationType","language","params","replace","validateField","validationRules","isValid","rule","param","Object","entries","errorType"],"sources":["/Users/pascalseeber/Desktop/survey-process-intelligence-main/src/utils/validation.js"],"sourcesContent":["import { t } from '../localization';\n\nexport const validators = {\n  required: (value) => {\n    if (value === undefined || value === null) return false;\n    if (typeof value === 'string') return value.trim() !== '';\n    if (Array.isArray(value)) return value.length > 0;\n    return true;\n  },\n  email: (value) => {\n    if (!value) return true; \n    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    return emailRegex.test(value);\n  },\n  minLength: (value, minLength) => {\n    if (!value) return true; \n    return String(value).length >= minLength;\n  },\n  maxLength: (value, maxLength) => {\n    if (!value) return true;\n    return String(value).length <= maxLength;\n  },\n  pattern: (value, pattern) => {\n    if (!value) return true;\n    const regex = new RegExp(pattern);\n    return regex.test(value);\n  },\n  min: (value, min) => {\n    if (!value && value !== 0) return true;\n    const num = Number(value);\n    return !isNaN(num) && num >= min;\n  },\n  max: (value, max) => {\n    if (!value) return true;\n    return Number(value) <= max;\n  },\n  minDate: (value, minDate) => {\n    if (!value) return true;\n    return new Date(value) >= new Date(minDate);\n  },\n  maxDate: (value, maxDate) => {\n    if (!value) return true;\n    return new Date(value) <= new Date(maxDate);\n  },\n  numeric: (value) => {\n    if (!value) return true;\n    return !isNaN(Number(value));\n  }\n};\n\n/**\n * Get localized error message for validation errors\n * @param {string} validationType - Type of validation that failed\n * @param {string} language - Current language code\n * @param {any} params - Additional parameters for the error message\n * @returns {string} - Localized error message\n */\nexport const getErrorMessage = (validationType, language, params) => {\n  switch (validationType) {\n    case 'required':\n      return t('validationRequired', language);\n    case 'email':\n      return t('validationEmail', language) || 'Please enter a valid email address';\n    case 'minLength':\n      return t('validationMinLength', language, { length: params }).replace('{length}', params);\n    case 'maxLength':\n      return t('validationMaxLength', language, { length: params }).replace('{length}', params);\n    case 'pattern':\n      return t('validationPattern', language);\n    case 'min':\n      return t('validationMin', language, { min: params }).replace('{min}', params);\n    case 'max':\n      return t('validationMax', language, { max: params }).replace('{max}', params);\n    case 'minDate':\n      return t('validationMinDate', language, { minDate: params }).replace('{minDate}', params);\n    case 'maxDate':\n      return t('validationMaxDate', language, { maxDate: params }).replace('{maxDate}', params);\n    default:\n      return t('validationGeneric', language) || 'Invalid input';\n  }\n};\n\n/**\n * Validate a field value against validation rules\n * @param {any} value - The value to validate\n * @param {Object} validationRules - Object containing validation rules\n * @returns {Object} - { isValid: boolean, errorType: string, param: any }\n */\nexport const validateField = (value, validationRules = {}) => {\n  if (!validationRules) return { isValid: true };\n  \n  for (const [rule, param] of Object.entries(validationRules)) {\n    if (rule === 'required' && param && !validators.required(value)) {\n      return { isValid: false, errorType: 'required' };\n    }\n    if (rule === 'email' && param && !validators.email(value)) {\n      return { isValid: false, errorType: 'email' };\n    }\n    if (rule === 'minLength' && !validators.minLength(value, param)) {\n      return { isValid: false, errorType: 'minLength', param };\n    }\n    if (rule === 'maxLength' && !validators.maxLength(value, param)) {\n      return { isValid: false, errorType: 'maxLength', param };\n    }\n    if (rule === 'pattern' && !validators.pattern(value, param)) {\n      return { isValid: false, errorType: 'pattern' };\n    }\n    if (rule === 'min' && !validators.min(value, param)) {\n      return { isValid: false, errorType: 'min', param };\n    }\n    if (rule === 'max' && !validators.max(value, param)) {\n      return { isValid: false, errorType: 'max', param };\n    }\n    if (rule === 'numeric' && !validators.numeric(value, param)) {\n      return { isValid: false, errorType: 'numeric', param };\n    }\n    if (rule === 'minDate' && !validators.minDate(value, param)) {\n      return { isValid: false, errorType: 'minDate', param };\n    }\n    if (rule === 'maxDate' && !validators.maxDate(value, param)) {\n      return { isValid: false, errorType: 'maxDate', param };\n    }\n  }\n  \n  return { isValid: true };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}